<h1>
Практическое задание №13<br><br>
Ремешевский В.А.<br>
ПИМО-01-25
</h1>

<h2><b>Тема</b><br>
Профилирование Go-приложения (pprof). Измерение времени работы функций</h2>

# Цели работы

1. Научиться подключать и использовать профилировщик `pprof` для анализа CPU, памяти, блокировок и горутин.
2. Освоить базовые техники измерения времени выполнения функций (ручные таймеры, бенчмарки).
3. Научиться читать отчёты `go tool pprof`, строить графы вызовов и находить “узкие места”.
4. Сформировать практические навыки оптимизации кода на основании метрик.

---

# PPROF-LAB

## Краткое описание стенда

**PPROF-LAB** — это лабораторный проект на Go (версия 1.25.1), предназначенный для освоения инструментов профилирования и оптимизации кода.  
В проекте реализованы функции для вычисления чисел Фибоначчи, ручные таймеры, бенчмарки и подключён pprof для анализа производительности.

## Структура проекта

```
pprof-lab/
├── assets/
├── cmd/
│   └── api/
│       └── main.go
├── internal/
│   └── work/
│       ├── slow.go
│       ├── slow_test.go
│       └── timer.go
├── go.mod
├── README.md
```

---

## Как начать работу

### Инициализация и установка зависимостей

```sh
cd pprof-lab
go mod init example.com/pprof-lab
```

### Запуск приложения

```powershell
go run ./cmd/api
```

---

## Скриншоты

### Анализ при помощи утилиты hey
![hey_prof](assets/hey_prof.png)

### Индекс pprof
![index_prof](assets/index_prof.png)

### CPU-профиль: top
![cpu_prof_top](assets/cpu_prof_top.png)

### CPU-профиль: graph/web
![cpu_prof_graph](assets/cpu_prof_graph.png)

### HEAP-профиль (анализ аллокаций)

**HEAP-профиль - inuse_space**
![heap_prof_inuse](assets/heap_prof_inuse.png)

**HEAP-профиль - alloc_space**
![heap_prof_alloc](assets/heap_prof_alloc.png)

> На HEAP-профиле видно, что основное количество аллокаций связано с рекурсивными вызовами функции `Fib`, а также с внутренними структурами pprof и стандартной библиотеки. После оптимизации аллокации практически отсутствуют.

### Логи ручных таймеров и бенчмарки

Запуск бенчмарков:
```powershell
cd .\cmd\api
go test -run=^$ -bench=BenchmarkFib -benchmem
```

**До оптимизации:**  
![benchlogs_before](assets/benchlogs_before.png)  

**После оптимизации:**  
![benchlogs_after](assets/benchlogs_after.png)  

---

## Описание внесённых изменений

В исходной версии использовалась рекурсивная реализация функции `Fib`, что приводило к экспоненциальному времени работы и огромному количеству вызовов.  
Для оптимизации была добавлена функция `FibFast`, использующая итеративный подход (или мемоизацию), что позволило сократить время выполнения с миллисекунд до наносекунд.  
Это радикально улучшило производительность, что видно по результатам бенчмарков и логам таймеров.

---

## Сравнительная таблица метрик до/после

| Версия         | ns/op      | B/op | allocs/op |
|----------------|------------|------|-----------|
| Fib (до)       | 5,510,960  | 0    | 0         |
| FibFast (после)| 5.2        | 0    | 0         |

---

## Выводы

В ходе работы были выявлены и устранены узкие места в производительности с помощью pprof и бенчмарков.  
Оптимизация функции Фибоначчи позволила добиться колоссального прироста скорости (в миллионы раз).  
`pprof` и ручные метрики помогли наглядно увидеть эффект оптимизации.  
В дальнейшем можно анализировать и оптимизировать другие части кода, а также использовать pprof для поиска утечек памяти и блокировок.